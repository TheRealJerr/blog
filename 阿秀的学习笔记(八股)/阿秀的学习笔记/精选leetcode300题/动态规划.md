# 动态规划板块

## 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

```cpp
#define NUM 1000000007
class Solution {
public:
struct Node {
	Node(int val, int pos) :_val(val), _pos(pos) {};
	int _val;
	int _pos;
};
int Fib(int N, int M, int* arr)
{
	int pos = 0;
	Node first(1, 1);
	Node second(2, 2);
	if (pos < M && arr[pos] == 1) {
		first._val = 0;
		second._val = 1;
		pos++;
	}
	if (pos < M && arr[pos] == 2) {
		second._val = 0;
		pos++;
	}
	int n = N;
	if (n == 1)
		return first._val;
	else if (n == 2)
		return second._val;
	while (n > 2)
	{
		Node newnode(0, 0);
		newnode._val = (first._val + second._val);
		newnode._pos = second._pos + 1;
		if (pos < M && arr[pos] == newnode._pos) {
			pos++;
			newnode._val = 0;
		}
		first = second;
		second = newnode;
		n--;
	}
	return second._val;
}
    int climbStairs(int n) {
        return Fib(n,0,nullptr);
    }
};
```

## 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23

```cpp
class Solution {
public:
    using ll = long long int;
    int maxSubArray(vector<int>& nums) {
        // dp[i]表示以i结尾的最大和 
        int n = nums.size();
        vector<int> dp(n + 1);
        dp[0] = -10000;
        int maxValue = -INT32_MAX;
        for(int i = 0;i < nums.size();i++)
        {
            dp[i + 1] = std::max(nums[i], dp[i] + nums[i]);
            maxValue = std::max(maxValue, dp[i + 1]);
        }

        return maxValue;
    }
};
```

## 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int max_value = 0;
        int consume_price = prices[0];
        // consume_price表示最低买入价格
        for(int i = 1;i < prices.size();i++)
        {
            if(prices[i] > consume_price) max_value = std::max(max_value , prices[i] - consume_price);
            else consume_price = prices[i];
        }

        return max_value;
    }
};
```

## 122. 买卖股票的最佳时机 II

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 

示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
最大总利润为 4 。
示例 3：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        // 多状态dp
        // f[i]表示第i天没有持有股票, 最大利润
        // g[i]表示第i天持有股票, 最大利润
        int n = prices.size();
        // 初始化
        std::vector<int> f(n + 1), g(n + 1);
        f[1] = 0, g[1] = -prices[0];
        //
        for(int i = 2;i <= n;i++)
        {
            auto price = prices[i - 1];
            g[i] = std::max(g[i - 1], f[i - 1] - price);
            f[i] = std::max(g[i] + price, f[i - 1]);
        }

        return f[n];
    }
};
```
## 123. 买卖股票的最佳时机 III

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3：

输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
示例 4：

输入：prices = [1]
输出：0 

### **思路**

> 经典多状态dp
> 直接考虑可能存在的状态即可
> 1. 什么没都买过
> 2. 第一次持有股票
> 3. 买过一次股票, 并且已经卖出
> 4. 第二次持有股票
> 5. 已经完成两次股票的购买

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        // 直接考虑可能存在的状态即可
        // 1. 什么没都买过
        // 2. 第一次持有股票
        // 3. 买过一次股票, 并且已经卖出
        // 4. 第二次持有股票
        // 5. 已经完成两次股票的购买
        int op_size = 5;
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(op_size, 0));
        // 第一天初始化
        // 我们可以假定最多两次每天可以买入, 并且卖出
        dp[0][0] = dp[0][2] = dp[0][4] = 0;
        dp[0][1] = dp[0][3] = -prices[0];
        //
        for(int i = 1;i < n;i++)
        {
            auto price = prices[i];
            dp[i][1] = std::max(dp[i - 1][1], dp[i][0] - price);
            dp[i][2] = std::max(dp[i][1] + price, dp[i - 1][2]);
            dp[i][3] = std::max(dp[i][2] - price, dp[i - 1][3]);
            dp[i][4] = std::max(dp[i - 1][4], dp[i][3] + price);
        }

        return std::max(0, std::max(dp[n - 1][2], dp[n - 1][4]));
    }
};
```

## 123. 买卖股票的最佳时机 III

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
示例 2：

输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
示例 3：

输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
示例 4：

输入：prices = [1]
输出：0

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        // 直接考虑可能存在的状态即可
        // 1. 什么没都买过
        // 2. 第一次持有股票
        // 3. 买过一次股票, 并且已经卖出
        // 4. 第二次持有股票
        // 5. 已经完成两次股票的购买
        int op_size = 5;
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(op_size, 0));
        // 第一天初始化
        // 我们可以假定最多两次每天可以买入, 并且卖出
        dp[0][0] = dp[0][2] = dp[0][4] = 0;
        dp[0][1] = dp[0][3] = -prices[0];
        //
        for(int i = 1;i < n;i++)
        {
            auto price = prices[i];
            dp[i][1] = std::max(dp[i - 1][1], dp[i][0] - price);
            dp[i][2] = std::max(dp[i][1] + price, dp[i - 1][2]);
            dp[i][3] = std::max(dp[i][2] - price, dp[i - 1][3]);
            dp[i][4] = std::max(dp[i - 1][4], dp[i][3] + price);
        }

        return std::max(0, std::max(dp[n - 1][2], dp[n - 1][4]));
    }
};
```

## 188. 买卖股票的最佳时机 IV

给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
示例 2：

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) 
    {
        vector<int> buy(k + 1, -INT32_MAX);
        vector<int> sell(k + 1, 0);
        for(auto price : prices)
        {
            for(int i = 1;i <= k;i++)
            {
                buy[i] = max(buy[i], sell[i - 1] - price);
                sell[i] = max(sell[i], buy[i] + price);
            }
        }
        return sell[k];
    }
};
```