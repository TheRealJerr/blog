# 双指针板块

## **925. 长按键入**

[leetcode链接](https://leetcode.cn/problems/long-pressed-name/)

你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

### **思路**

> 这道题目只要是末尾的边界条件比较恶心一点

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) 
    {
        int cur = 0;
        if(name[0] != typed[0]) return false;
        for(auto ch : name)
        {
            if(ch == typed[cur])
            {
                // 匹配成功
                ++cur;
            }
            else 
            {
                // 匹配失败
                // 可能上一个字符多键入了
                auto prev_chr = typed[cur - 1];
                while(cur < typed.size() && typed[cur] == prev_chr) cur++;

                if(cur < typed.size() && typed[cur] == ch) 
                {
                    cur++;
                }
                else return false; 
            }
            
        }
        // 找找还有没有词
        auto prev_chr = typed[cur - 1];
        while(cur < typed.size() && typed[cur] == prev_chr) cur++;

        if(cur < typed.size()) return false;
        return true;
    }
};
```


## **532. 数组中的 k-diff 数对**

[leetcode链接](https://leetcode.cn/problems/k-diff-pairs-in-an-array/description/)

给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。

k-diff 数对定义为一个整数对 (nums[i], nums[j]) ，并满足下述全部条件：

0 <= i, j < nums.length
i != j
|nums[i] - nums[j]| == k
注意，|val| 表示 val 的绝对值。

 

示例 1：

输入：nums = [3, 1, 4, 1, 5], k = 2
输出：2
解释：数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。
尽管数组中有两个 1 ，但我们只应返回不同的数对的数量。
示例 2：

输入：nums = [1, 2, 3, 4, 5], k = 1
输出：4
解释：数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。
示例 3：

输入：nums = [1, 3, 1, 5, 4], k = 0
输出：1
解释：数组中只有一个 0-diff 数对，(1, 1) 

### **思路**

> 第一版的思路就是直接查找, 但是k == 0单独讨论一下, 不然确实不好处理

```cpp
class Solution {
public:
    int getPrevDiffNum(vector<int>& num,int pos)
    {
        int res = pos - 1;
        while(res >= 0 && num[res] == num[pos]) res--;

        return res;
        // -1
    }

    int getNextDiffNum(vector<int>& num,int pos)
    {
        int res = pos + 1;
        while(res < num.size() && num[res] == num[pos]) res++;

        return res;
    }
    int findPairs(vector<int>& nums, int k) 
    {
        // 暴力算法
        // 单独处理k == 0
       
        sort(nums.begin(), nums.end());
        if(k == 0)
        {
            int count = 0;
            for(int i = 0;i < nums.size();i = getNextDiffNum(nums,i))
                if(i + 1 < nums.size() && nums[i] == nums[i + 1]) count++;
            return count;
        }
        int n = nums.size();
        int count = 0;
        for(int i = 0;i < n;i = getNextDiffNum(nums,i))
        {
            auto prev_diff_pos = i;
            while(prev_diff_pos != -1)
            {
                if(nums[i] - nums[prev_diff_pos] >= k) break;

                prev_diff_pos = getPrevDiffNum(nums, prev_diff_pos);
            }
            if(prev_diff_pos != -1 && nums[i] - nums[prev_diff_pos] == k) 
            {
                count++;
            }

        }

        return count;
    }
};
```
### **思路**

> 我们在查找的时候可以使用二分进行速度的优化。确实快了一些

```cpp
class Solution {
public:
    int getPrevDiffNum(vector<int>& num,int pos)
    {
        int res = pos - 1;
        while(res >= 0 && num[res] == num[pos]) res--;

        return res;
        // -1
    }

    int getNextDiffNum(vector<int>& num,int pos)
    {
        int res = pos + 1;
        while(res < num.size() && num[res] == num[pos]) res++;

        return res;
    }
    int findPairs(vector<int>& nums, int k) 
    {
        // 暴力算法
        // 单独处理k == 0
       
        sort(nums.begin(), nums.end());
        if(k == 0)
        {
            int count = 0;
            for(int i = 0;i < nums.size();i = getNextDiffNum(nums,i))
                if(i + 1 < nums.size() && nums[i] == nums[i + 1]) count++;
            return count;
        }
        // 如果k != 0, 首先进行去重
        // 通过二分查找进行优化之前的逻辑
        int count = 0;
        for(int i = getNextDiffNum(nums,0);i < nums.size();i = getNextDiffNum(nums,i))
        {
            int left = 0, right = i - 1;
            while(left < right)
            {
                int mid = left + (right - left) / 2;
                if(nums[i] - nums[mid] > k) left = mid + 1;
                else right = mid;
            }
            if(nums[i] - nums[left] == k) count++;
        }
        return count;
    }
};
```