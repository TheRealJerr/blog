# Redis进阶

## 持久性

Redis是内存级别的数据库, 其实是不持久的, 为了让Redis持久化, 只有将数据存储在硬盘里面, 但是Redis相比于MySql, 他的速度快很多,
为了保证速度快, 怎么进行平衡这些关系, 最终Redis决定既存储在内存, 又存储在硬盘, 实际上也可能存在差异。

Redis写入硬盘的时候也会进行性能的优化, 让他区别于MySQL, 有着很大的性能优势。

### Redis快照

- 手动触发

    - save : 由于Redis是单线程, 可能阻塞Redis的其他客户端

    - bgsave : backgroud save, 不会影响Redis服务器处理其他的请求, 这里的实现方式不是多线程, 此处Redis使用的"多进程"的方式实现的并发编程, 但是由于Windows上面进程开销很大

- 自动触发

    配置在配置脚本中, 定期多久进行触发

通过rdb进行压缩, 生成一个rdb的成本是很高的, 不能太过频繁的进行rdb拷贝的这个操作



## AOF

append only file通过记录Redis的操作进行持久化

**会影响Redis的性能吗**

不会, 他并不会怎么影响Redis的性能, AOF并不是通过工作线程写入硬盘, 而是写入内存级缓冲区, 等到特定的时候进行写入硬盘

**如果缓冲区中的数据没来得及写入, 进程就挂掉了, 会出现数据都是吗**

会, Redis的速度很快, 所以鱼与熊掌不可兼得

Redis提供了一些选项

- always : 频率最高

- everysec : 每秒

- no : 通过os控制fsync控制频率

Redis存在整理aof的机制, 能够整理合并删除一些冗余的操作。

内存中的文件结果, 已经是文件整理后的结果了, 区别与rdb就是二进制和文本文件的差别

**aof对于fork后的新的数据**, redis通过aof_rewrite_buf进行fork后续的时间段进行数据的写入, 这是区别于rdb的关键点, 这也是为什么rdb是定时备份, aof是实时备份。

**为什么aof_rewrite_buf**还要保证写到旧的aof里面, 因为如果新的数据出现问题, 我们还是需要保证旧的aof文件。


### 混合持久化

aof本来通过文本进行写入文件, Redis后续就引入了混合持久化, 结合rdb和aof的特点, Redis将操作/请求通过rdb的格式写入到aof文件中, 后续rewrite中进行的操作, 通过aof文本格式进行追加

如果aof和rdb同时启动, 我们的Redis以什么为主呢？以aof为主, 这个时候rdb就会直接被忽略。

## Redis的事务

- 原子性 : 将多个命令进行打包

- 一致性 : redis没有约束, 没有回滚的机制, 可能引起数据的一致性

- 持久化 : 不具备持久性, 内存级数据库, rdb和aof只是锦上添花

- 隔离性 : 单线程模型, 没有隔离性的问题

### Redis和MySQL的区别

- Redis不像MySQL那样会针对出现问题的事务进行回滚。

### Redis实现事务

Redis开启事务, 客户端输入的命令, 就会存储在服务器中的任务队列中, Redis会将队列中的事务处理结束, 才会处理其他客户端的请求/操作

### Redis事务相关的命令



- 开启事务 : multi, 存放进入服务器的事务队列, 类似SQL中的start transaction

- 执行命令 : exec , 类似SQL中的commit

- 取消事务: discard, 类似rollback

- watch: 可以观察外部修改, 帮助我们感知外部的变化

    watch的实现方式, 类似于乐观锁和悲观锁, 根据锁冲突的预期概率进行的预期。当一个客户端watch key, 当我们的一个客户端执行watch的时候, 这个时候会生成版本号, 其他客户端修改这个key的时候, 会使的版本号进行增长, 
    所以我们的watch客户端就能够该知道key的变化, 这种锁的机制不同于std::mutex里面的悲观锁, 他的核心是我们的操作失败, 而不是加锁阻塞

## Redis的主从复制

## Redis哨兵

## Redis集群

## Redis实现分布式锁

