C++ 类型萃取（Type Traits）是一种在编译时检查和操作类型特性的技术，主要用于模板元编程（Template Metaprogramming）。它允许我们在编译期间获取类型的属性（如是否是整数、是否有默认构造函数等），并根据这些属性进行不同的代码生成。

---

## **1. 标准库 `<type_traits>`**
C++11 引入了 `<type_traits>` 头文件，提供了许多现成的类型萃取工具，主要分为三类：

### **(1) 类型属性检查（Primary Type Categories）**
检查类型的基本属性：
```cpp
#include <type_traits>

std::is_void<T>::value       // 是否是 void
std::is_integral<T>::value   // 是否是整数类型（int, char, bool 等）
std::is_floating_point<T>::value // 是否是浮点类型
std::is_array<T>::value      // 是否是数组
std::is_pointer<T>::value    // 是否是指针
std::is_reference<T>::value  // 是否是引用
std::is_class<T>::value      // 是否是类或结构体
std::is_function<T>::value   // 是否是函数
```

### **(2) 类型修饰符操作（Type Modifiers）**
修改或调整类型：
```cpp
std::remove_const<T>::type      // 移除 const
std::add_const<T>::type         // 添加 const
std::remove_reference<T>::type  // 移除引用
std::add_lvalue_reference<T>::type // 添加左值引用
std::decay<T>::type            // 类似函数参数退化（移除引用、const、数组转指针等）
```

### **(3) 类型关系检查（Type Relationships）**
检查类型之间的关系：
```cpp
std::is_same<T, U>::value      // 判断两个类型是否相同
std::is_base_of<Base, Derived>::value // 判断 Base 是否是 Derived 的基类
std::is_convertible<From, To>::value // 判断 From 是否能隐式转换为 To
```

---

## **2. 如何使用类型萃取？**
### **(1) 基本用法**
```cpp
#include <iostream>
#include <type_traits>

template<typename T>
void check_type() {
    if (std::is_integral<T>::value) {
        std::cout << "T is an integral type\n";
    } else {
        std::cout << "T is NOT an integral type\n";
    }
}

int main() {
    check_type<int>();      // 输出: T is an integral type
    check_type<float>();    // 输出: T is NOT an integral type
    return 0;
}
```

### **(2) 结合 `if constexpr`（C++17）**
```cpp
#include <iostream>
#include <type_traits>

template<typename T>
void print_info() {
    if constexpr (std::is_pointer<T>::value) {
        std::cout << "T is a pointer\n";
    } else if constexpr (std::is_integral<T>::value) {
        std::cout << "T is an integer\n";
    } else {
        std::cout << "T is something else\n";
    }
}

int main() {
    print_info<int>();      // T is an integer
    print_info<int*>();     // T is a pointer
    print_info<float>();    // T is something else
    return 0;
}
```

### **(3) `std::enable_if` 实现 SFINAE**
```cpp
#include <type_traits>

// 仅当 T 是整数类型时才启用该函数
template<typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
void process_integer(T value) {
    std::cout << "Processing integer: " << value << "\n";
}

int main() {
    process_integer(42);    // OK
    // process_integer(3.14); // 编译错误，因为 double 不是整数
    return 0;
}
```

---

## **3. 自定义类型萃取**
如果标准库的类型萃取不够用，可以自己实现一个：

### **(1) 检查类型是否有某个成员函数**
```cpp
#include <type_traits>

// 检测类型 T 是否有 `void serialize()` 方法
template<typename T>
class has_serialize {
    template<typename U>
    static auto test(int) -> decltype(std::declval<U>().serialize(), std::true_type{});

    template<typename U>
    static std::false_type test(...);

public:
    static constexpr bool value = decltype(test<T>(0))::value;
};

struct MyClass {
    void serialize() {}
};

int main() {
    std::cout << has_serialize<MyClass>::value; // 输出 1（true）
    std::cout << has_serialize<int>::value;    // 输出 0（false）
    return 0;
}
```

### **(2) 检查类型是否可哈希**
```cpp
#include <functional>
#include <type_traits>

template<typename T>
struct is_hashable {
    template<typename U>
    static auto test(int) -> decltype(std::hash<U>{}(std::declval<U>()), std::true_type{};

    template<typename U>
    static std::false_type test(...);

public:
    static constexpr bool value = decltype(test<T>(0))::value;
};

int main() {
    std::cout << is_hashable<int>::value;      // 1（true）
    std::cout << is_hashable<std::string>::value; // 1（true）
    std::cout << is_hashable<std::vector<int>>::value; // 0（false）
    return 0;
}
```

---

## **4. 总结**
| 用途 | 方法 |
|------|------|
| **检查类型属性** | `std::is_integral<T>`, `std::is_class<T>` |
| **修改类型** | `std::remove_const<T>`, `std::add_pointer<T>` |
| **类型关系** | `std::is_same<T, U>`, `std::is_base_of<Base, Derived>` |
| **SFINAE 控制** | `std::enable_if<Condition, T>` |
| **自定义萃取** | 使用 `decltype` + `SFINAE` 检测成员 |

类型萃取广泛应用于：
- **模板元编程**（如 `std::vector` 对不同类型优化）
- **SFINAE**（替换失败不是错误，用于条件编译）
- **编译期优化**（如 `if constexpr` 选择不同代码路径）

C++20 引入了 **Concepts**，可以更直观地约束模板参数，但类型萃取仍然是模板元编程的重要基础。